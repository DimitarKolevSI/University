#include<iostream>
#include<Windows.h>
#include <cstdlib>
#include <vector>
#include <ctime>
#include <algorithm>
#include <string>
unsigned counter = 0;
struct Option
{
	Option(const std::string&, const double);
	double val = 0;
	std::string text;
};
Option::Option(const std::string& txt, const double val) : text(txt), val(val)
{
}
class Question
{
public:
	Question(const std::string&);
	void AddOption(const std::string&, const double);
	void AskQuestion();
	int AnswerQuestion();
private:
	std::string m_Question;
	std::vector<Option>m_Answers;
	double m_Score = 0;
};
void Question::AddOption(const std::string& rhs, const double val)
{
	Option opt(rhs, val);
	m_Answers.push_back(opt);
}
Question::Question(const::std::string& task) : m_Question(task)
{
}
int Randomize(const int i)
{
	return std::rand() % i;
}
void Question::AskQuestion()
{
	std::cout << m_Question << "\n\n";
	std::srand(unsigned(std::time(0)));
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		std::swap(m_Answers[Randomize(m_Answers.size())], m_Answers[Randomize(m_Answers.size())]);
	for (unsigned i = 0; i < m_Answers.size(); ++i)
	{
		char ind = i + 65;
		std::cout << ind << ' ' << m_Answers[i].text << '\n';
	}
}

int Question::AnswerQuestion()
{
	char tmp = 'v';
	unsigned tmpToInt;
	std::cin >> tmp;
	tmpToInt = tmp;
	do
	{
		if (tmpToInt < 97)
			tmpToInt -= 65;
		else
			tmpToInt -= 97;
		m_Score += m_Answers[tmpToInt].val;
		std::cin >> tmp;
		tmpToInt = tmp;
	} while (tmp != 's' && tmp != 'S');
	std::cout << "Резултат: " << m_Score << "\nВерен отговор(i): ";
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		if (m_Answers[i].val > 0)
			std::cout << char(i + 65) << ' ';
	std::cout << "\nВъведи някой символ";
	if (m_Score > 0)
		counter++;
	return m_Score;
}
int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	std::cout << "Подготовка за изпит по УСИ\nИзготвен от Д.К.,кодът е от Mapmo, Dakata, Ikbal i M.\n";
	std::cout << "За да отговорите на някой въпрос въведете буквата(буквите) и когато сте готови въведете 's'\n";
	std::cout << "Съобразете се как работи std::cin\nАко желаете симулация без повторни въпроси въведете r\nАко желаете въпросите, които сте объркали да се запазват натиснете произволен бутон\n";
	char useless;
	std::cin >> useless;
	bool flag = (useless == 'r' ? 1 : 0);
	system("CLS");
	std::vector<Question> exam;
	std::srand(unsigned(std::time(0)));

	Question q1("При гъвкавите модели на софтуерни процеси единственият работен продукт, който се доставя е работеща програма.");
	q1.AddOption("Истина", 1);
	q1.AddOption("Лъжа", -1);
	exam.push_back(q1);

	Question q2("Кое от следните е вярно при т.нар. тънък (thin) клиент?");
	q2.AddOption("Управлението на данните и логиката на приложението се извършват при клиента", 1);
	q2.AddOption("Представянето и управлението на данните се извършват при клиента", -1);
	q2.AddOption("Само погиката на приложението се намира при клиента", -1);
	q2.AddOption("Използва се при равноправни (реег-2-реег) реализации на системата", -1);
	q2.AddOption("Само представянето на информацията се намира при клиента", -1);
	exam.push_back(q2);

	Question q3("Кое от следните не е стъпка при Requirements engineering?");
	q3.AddOption("Извличане", -1);
	q3.AddOption("Проектиране", 1);
	q3.AddOption("Анализ", -1);
	q3.AddOption("Документиране", -1);
	exam.push_back(q3);

	Question q4("Чрез изчерпателно тестване е възможно да се отстранят дефектите на софтеура преди да се предаде на потребителя");
	q4.AddOption("Лъжа", 1);
	q4.AddOption("Истина", -1);
	exam.push_back(q4);

	Question q5("Кои от изброените НЕ са характерни за гъвкавата методология ХР?");
	q5.AddOption("Инкременти се доставят на клиента на 4 седмици", 0.5);
	q5.AddOption("Планът за имплементация и бюджета се базира на потребителски истории(user stories)", 0.5);
	q5.AddOption("Има непрекъснат рефакторинг на кода", -1);
	q5.AddOption("Дизайнът е отворен към промени", -1);
	exam.push_back(q5);

	Question q6("Кое от следните твърдения е вярно за диаграмите на последователност(sequence) ? ");
	q6.AddOption("Използват се прекъснати стрелки за моделиране на върнат резултат", 1);
	q6.AddOption("Използват се за моделиране на статичната структура на софтуерната системата", -1);
	q6.AddOption("Не показват последователността от взаимодействието между обектите", -1);
	q6.AddOption("Не се препоръчва използването им при създаване на модели за критични по отношение на безопасността(safety critical) системи", -1);
	exam.push_back(q6);

	Question q7("Дизайнът на системите и документирането им.");
	q7.AddOption("Са важни дейности от софтуерното инженерство", 1);
	q7.AddOption("Нито едно от горните не е вярно", -1);
	q7.AddOption("Зависят от резултата от разработката на софтуерната система", -1);
	q7.AddOption("Са дейности от валидирането на софтуерни системи", -1);
	exam.push_back(q7);

	Question q8("Системите за реално време със синхронно диспечиризиране се характеризират с :");
	q8.AddOption("Висока предскаауемост и ниска реактивност", 1);
	q8.AddOption("Ниска предсказуемост и висока реактивност", -1);
	q8.AddOption("Ниска предсказуемост и ниска реактивност", -1);
	q8.AddOption("Висока предсказуемост и реактивност", -1);
	exam.push_back(q8);

	Question q9("Подредете от най-малко важни към най-важни за извличане на изискванията следните заинтересовани лица\n1) Менаджери\n2) Новопостъпил персонал\n3) Потребителите\n4) Средно ниво заинтересовани лица");
	q9.AddOption("1, 2, 4, 3", 1);
	q9.AddOption("2, 4, 1, 3", -1);
	q9.AddOption("2, 3, 4, 1", -1);
	q9.AddOption("1, 2, 3, 4", -1);
	exam.push_back(q9);

	Question q10("Каква е връзката между софтуерното инженерство и системното инженерство ? ");
	q10.AddOption("Софтуерното инженерство е част от системното инженерство", 1);
	q10.AddOption("Софтуерното инженерство и системното инженерство са едно и също нещо", -1);
	q10.AddOption("Системното инженерство е част от софтуерното инженерство", -1);
	q10.AddOption("Софтуерното инженерство и системното инженерство са независими инженерни дисциплини", -1);
	exam.push_back(q10);

	Question q11("Коя от следните не е характеристика на Скръм модела за разработване на софтуер?");
	q11.AddOption("Стабилни изисквания", 1);
	q11.AddOption("Tme-box график на работа", -1);
	q11.AddOption("Инкрементално разработване", -1);
	q11.AddOption("Гъвкавост", -1);
	exam.push_back(q11);

	Question q12("В стила клиент-сървър, системата се моделира като набор от сървъри, предоставящи услуги и набор от клиенти, които ги използват.");
	q12.AddOption("Истина", 1);
	q12.AddOption("Лъжа", -1);
	exam.push_back(q12);

	Question q13("По принцип е възприето да се смята, че ако прилагания софтуерен процес е слаб, то не може да се създадат софтуерни продукти с високо качество");
	q13.AddOption("Истина", 1);
	q13.AddOption("Лъжа", -1);
	exam.push_back(q13);

	Question q14("Кои от изброените не са верни за Unit тестването? ");
	q14.AddOption("Black Box тестване", 0.5);
	q14.AddOption("Тестване по време на разработването за да се установят бъгове и дефекти", -1);
	q14.AddOption("Извършва се от независим екип ", 0.5);
	q14.AddOption("Тестват се индивидуалните компоненти независимо и в изолация", -1);
	exam.push_back(q14);

	Question q15("Кое от изброените не е цел на моделите на софтуерен процес?");
	q15.AddOption("Обобщения от частното към общото за разработване на софтуер", 1);
	q15.AddOption(" Формиране на общо разбиране у участниците в разработването на софтуер за дейностите, ресурсите и ограниченията", -1);
	q15.AddOption("Намиране и оценяване на подходящи дейности за постигане на целите на процеса", -1);
	q15.AddOption(" Намиране на несъответствия, излишества и пропуски в процеса от разработващия екип.което от своя страна му помага да подобри процеса", -1);
	exam.push_back(q15);

	Question q16("Кое от следните е начин за превантивна (предварителна) поддръжка ? ");
	q16.AddOption("Рефакторинг (refactoring) на кода", -1);
	q16.AddOption("Намаляване на дублиращи се части от кода", -1);
	q16.AddOption("Всички изброени са верни", 1);
	q16.AddOption("Използване на подразбиращи се имена на променливи", -1);
	exam.push_back(q16);

	Question q17("Механизмът на наследяване в обектно-ориентираният дизайн се използва за : ");
	q17.AddOption("Многократна употреба на код", 1);
	q17.AddOption("Саздаване на инстанции на обекти", -1);
	q17.AddOption("Създаване на методи с по-малко входни параметри", -1);
	q17.AddOption("Изключване на необходимостта от използване на условни оператори", -1);
	exam.push_back(q17);

	Question q18("Диаграмите на състоянията (State chart) представляват: ");
	q18.AddOption("граф, като възлите на графа моделират различни състояния на системата, а дъгите - събитията, които водят до преход от едно състояние в друго", 1);
	q18.AddOption("нито едно от посочените не е вярно", -1);
	q18.AddOption("граф, като възлите на графа моделират различни потребители на системата, а дъгите - събитията, които водят до преход от едно състояние в друго", -1);
	q18.AddOption("граф, като възлите на графа моделират различни състояния на системата, а дъгите - задължително посочват взаимодействието на потребителите с нея", -1);
	exam.push_back(q18);

	Question q19("Къде би било най-подходящо прилагането на гъвкава методология ?");
	q19.AddOption("При разработването на малки или средни продукти", 1);
	q19.AddOption("При географски разпределени екипи", -1);
	q19.AddOption("При разработването на real-time системи", -1);
	q19.AddOption("При разработването на големи комплексни системи", -1);
	q19.AddOption("При системи изискващи детайлна спецификация и дизайн.", -1);
	exam.push_back(q19);

	Question q20("На кои два вида изисквания се дава приоритет при Менажиране на изискванията ? ");
	q20.AddOption("Функционални и нефункционални", 1);
	q20.AddOption("Стабилни и променящи се", -1);
	q20.AddOption("Потребителски и на разработчиците", -1);
	exam.push_back(q20);

	Question q21("Кои от изброените са характерни за равзработването базирано на планиране(Plan - driven development) ?");
	q21.AddOption("Постъпково разработване", 0.5);
	q21.AddOption("Детайлна спецификация и дизайн", 0.5);
	q21.AddOption("Регулярно представяне на версии на системата на клиента", -1);
	q21.AddOption("Толерират се промените", -1);
	exam.push_back(q21);

	Question q22("Кои от изброените са стандарти за качество на процес?");
	q22.AddOption("Формат на плана на проекта", 0.5);
	q22.AddOption("Управление на промени", 0.5);
	q22.AddOption("Submission на нов код за версия на системата", -1);
	q22.AddOption("Java стил на програмиране", -1);
	exam.push_back(q22);

	Question q23("Sequence диаграмите се използват за моделиране на статични аспекти на софтуерните системи");
	q23.AddOption("Лъжа", 1);
	q23.AddOption("Истина", -1);
	exam.push_back(q23);

	Question q24("Семафорите представляват техника, която се използва за: ");
	q24.AddOption("Управление на общи за повече от един процес ресурси", 1);
	q24.AddOption("Управление на работата на потребителя със системата", -1);
	q24.AddOption("Управление на разработката на системи да реално време при големи екипи от хора", -1);
	q24.AddOption("Дефиниране на събитията които системата обработва", -1);
	exam.push_back(q24);

	Question q25("Нефункционалните изисквания към софтуерните системи");
	q25.AddOption("Поставят ограничения върху това как системата ще извършва своята функционалност", 1);
	q25.AddOption("Дефинират какво ще върши системата, докато не се използва от потребителите", -1);
	q25.AddOption("Нямат отношение към функционалността на системата", -1);
	q25.AddOption("Няма такова понятие", -1);
	exam.push_back(q25);

	Question q26("Какво трябва да включва документацията на софтуерната архитектура ? ");
	q26.AddOption("Всички посочени са верни", 1);
	q26.AddOption("Описание на интерфейсите на компонентите в системата", -1);
	q26.AddOption("Всички коментари към кода на системата", -1);
	q26.AddOption("Вариантите за тестване на системата", -1);
	exam.push_back(q26);

	Question q27(" Фокусът при валидационното тестване е да открие места, където потребителя ще може да види че софтуера не съответства на изискванията.");
	q27.AddOption("Лъжа", 1);
	q27.AddOption("Истина", -1);
	exam.push_back(q27);

	Question q28("Ако трябва да опишете конкретно използване на системата от различни потребители, каква диаграма бихте използвали ? ");
	q28.AddOption("UML диаграма на потребителските спучаи (use case)", 1);
	q28.AddOption("UML диаграма на активностите (activity)", -1);
	q28.AddOption("UML диаграма на последователност (sequence)", -1);
	q28.AddOption("UML клас (class) диаграма", -1);
	exam.push_back(q28);

	Question q29("Софтуерната валидация се постига чрез серия от тестове,извършени от потребителя спед като софтуера е внедрен в неговата работна среда.");
	q29.AddOption("Лъжа", 1);
	q29.AddOption("Истина", -1);
	exam.push_back(q29);

	Question q30("Разнородност в копията на модулите на дадена система НЕ може да се осигури чрез");
	q30.AddOption("Използване на формални методи за моделиране на изискванията към системата", 1);
	q30.AddOption("Разработка на идентични модули от различни екипи", -1);
	q30.AddOption("Стартиране на изпълнението на програмата в различни моменти от време", -1);
	q30.AddOption("Използване на различни компилатори", -1);
	exam.push_back(q30);

	Question q31("Коя от изброените не е фаза на прототипния модел?");
	q31.AddOption("Кодиране.", 1);
	q31.AddOption("Бърз план.", -1);
	q31.AddOption("Бърз дизайн.", -1);
	q31.AddOption("Конструиране.", -1);
	exam.push_back(q31);

	Question q32("Кои от изброените не са верни?");
	q32.AddOption("Инспекциите са вид динамична верификация", 0.5);
	q32.AddOption("Тестването е вид статична верификация", 0.5);
	q32.AddOption("Верификацията отговаря на въпроса Дали разбираме продукта правилно ? ", -1);
	q32.AddOption("Валидацията отговаря на въпроса Дали разработваме правилния продукт ? ", -1);
	exam.push_back(q32);

	Question q33("Кой от изброените е най-важният атрибут на качествения софтуер?");
	q33.AddOption("Отказоустойчивост /Fault-tolerance/.", 1);
	q33.AddOption("Използваемост /Usability/.", -1);
	q33.AddOption("Коректност /Correctness/.", -1);
	q33.AddOption("Повторна използваемост /Reusability/.", -1);
	exam.push_back(q33);

	Question q34("Кои от изброените UML диаграми не са подходящи за представяне на взаимодействието на системата с околната й среда (потребители и други системи) ? ");
	q34.AddOption("Package diagram.", 0.34);
	q34.AddOption("Class Diagram. ", 0.33);
	q34.AddOption("Deployment diagram.", 0.33);
	q34.AddOption("Use case diagram.", -1);
	q34.AddOption("Sequence diagram. ", -1);
	exam.push_back(q34); 
	
	Question q35("Кои от изброените са стандарти за качество на продукт?");
	q35.AddOption("Ревю на дизайна.",0.5);
	q35.AddOption("Структура на спецификация на изискванията.", 0.5);
	q35.AddOption("Пускане на нови версии на системата.", -1);
	q35.AddOption("Java стил на програмиране.", -1);
	exam.push_back(q35);

	Question q36("За кои от изброените понятия може да се каже, че подпомагат многократната употреба в обектно - ориентирания дизайн ? ");
	q36.AddOption("Абстракция.", 0.5);
	q36.AddOption("Наследяване.", 0.5);
	q36.AddOption("Верификация.", -1);
	q36.AddOption("Използване на публични атрибути.", -1);
	exam.push_back(q36);

	Question q37("За кои от изброените понятия се счита, че осъществяват многократната употреба в обектно - ориентирания дизайн ? ");
	q37.AddOption("Енкапсулация.", 0.5);
	q37.AddOption("Наследяване.", 0.5);
	q37.AddOption("Верификация.", -1);
	q37.AddOption("Използване на публични атрибути.", -1);
	exam.push_back(q37);

	Question q38("Каква е следната UML диаграма (Изчакване->Пресмятане)?");
	q38.AddOption("Нито едно от посочените.", 1);
	q38.AddOption("Use case diagram.", -1);
	q38.AddOption("Class diagram.", -1);
	q38.AddOption("Sequence diagram.", -1);
	exam.push_back(q38);
	  
	Question q39("Кои от изброените са верни при груповата кимуникация?");
	q39.AddOption("Добрата организация на работното място може да улесни комуникацията.", 0.5);
	q39.AddOption("Комуникацията е по-добра когато групата е смесена, а не само от един пол.", 0.5);
	q39.AddOption("Комуникацията е по-лесна когато в групата има еднакви личностни типове.", -1);
	q39.AddOption("Колкото по-голям е екипа, толкова по-лесна е вътрешнатa комуникация.", -1);
	q39.AddOption("Комуникацията е по-добра когато гупата е йерархично структурирана, отколкото когато е неформална.", -1);
	exam.push_back(q39);

	unsigned questionsCount = exam.size();
	for (unsigned i = 0; i < questionsCount; ++i)
		std::swap(exam[Randomize(exam.size())], exam[Randomize(exam.size())]);
	for (unsigned i = 0; i < exam.size(); ++i)
	{
		if (i == questionsCount)
		{
			std::cout << "Sekciq sus sgresheni vuprosi\nnatisnete nqkoy buton\n";
			std::cin >> useless;
			system("CLS");
		}
		std::cout << 1 + i << '/' << exam.size() << '\n';
		exam[i].AskQuestion();
		if (exam[i].AnswerQuestion() != 1 && !flag)
			exam.push_back(exam[i]);
		std::cin >> useless;
		system("CLS");
	}
	std::cout << "Congratulations for reaching the end!\nYour score is: " << counter << '/' << exam.size();
	std::cin >> useless;
	system("pause");
	return 0;
}