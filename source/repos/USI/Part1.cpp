#include<iostream>
#include<Windows.h>
#include <cstdlib>
#include <vector>
#include <ctime>
#include <algorithm>
#include <string>
unsigned counter = 0;
struct Option
{
	Option(const std::string&, const double);
	double val = 0;
	std::string text;
};
Option::Option(const std::string& txt, const double val) : text(txt), val(val)
{
}
class Question
{
public:
	Question(const std::string&);
	void AddOption(const std::string&, const double);
	void AskQuestion();
	int AnswerQuestion();
private:
	std::string m_Question;
	std::vector<Option>m_Answers;
	double m_Score = 0;
};
void Question::AddOption(const std::string& rhs, const double val)
{
	Option opt(rhs, val);
	m_Answers.push_back(opt);
}
Question::Question(const::std::string& task) : m_Question(task)
{
}
int Randomize(const int i)
{
	return std::rand() % i;
}
void Question::AskQuestion()
{
	std::cout << m_Question << "\n\n";
	std::srand(unsigned(std::time(0)));
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		std::swap(m_Answers[Randomize(m_Answers.size())], m_Answers[Randomize(m_Answers.size())]);
	for (unsigned i = 0; i < m_Answers.size(); ++i)
	{
		char ind = i + 65;
		std::cout << ind << ' ' << m_Answers[i].text << '\n';
	}
}

int Question::AnswerQuestion()
{
	char tmp = 'v';
	unsigned tmpToInt;
	std::cin >> tmp;
	tmpToInt = tmp;
	do
	{
		if (tmpToInt < 97)
			tmpToInt -= 65;
		else
			tmpToInt -= 97;
		m_Score += m_Answers[tmpToInt].val;
		std::cin >> tmp;
		tmpToInt = tmp;
	} while (tmp != 's' && tmp != 'S');
	std::cout << "Резултат: " << m_Score << "\nВерен отговор(i): ";
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		if (m_Answers[i].val > 0)
			std::cout << char(i + 65) << ' ';
	std::cout << "\nВъведи някой символ";
	if (m_Score > 0)
		counter++;
	return m_Score;
}
int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	std::cout << "Подготовка за изпит по УСИ\nИзготвен от Д.К.,кодът е от Mapmo, Dakata, Ikbal i M.\n";
	std::cout << "За да отговорите на някой въпрос въведете буквата(буквите) и когато сте готови въведете 's'\n";
	std::cout << "Съобразете се как работи std::cin\nАко желаете симулация без повторни въпроси въведете r\nАко желаете въпросите, които сте объркали да се запазват натиснете произволен бутон\n";
	char useless;
	std::cin >> useless;
	bool flag = (useless == 'r' ? 1 : 0);
	system("CLS");
	std::vector<Question> exam;
	std::srand(unsigned(std::time(0)));

	Question q1("Кое от избоените НЕ Е тип променящи се изисквания?");
	q1.AddOption("Последващи изисквания", -1);
	q1.AddOption("Мутиращи изисквания", -1);
	q1.AddOption("Проследими изисквания", 1);
	q1.AddOption("Съвместими изисквания", -1);
	exam.push_back(q1);

	Question q2("Кое от изброените НЕ Е функция на ревюто?");
	q2.AddOption("Тренировъчна функция", 1);
	q2.AddOption("Тестване на софтуера", -1);
	q2.AddOption("Изследване на артефактите на проекта", -1);
	q2.AddOption("Преглед на ппрогреса на проекта", -1);
	exam.push_back(q2);

	Question q3("Кое от изброените качества е най-важно за извличане на изискванията чрез интервюта?");
	q3.AddOption("Лидерски качества", -1);
	q3.AddOption("Мотивация", -1);
	q3.AddOption("Добра комуникация", 1);
	q3.AddOption("Способност за преговаряне", -1);
	q3.AddOption("Неутралитет", -1);
	exam.push_back(q3);

	Question q4("Кои изисквания НЕ СА зададени правилно?");
	q4.AddOption("Системата трябва да е максимално бърза", 0.5);
	q4.AddOption("Системата трябва да е User friendly", 0.5);
	q4.AddOption("Системата трябва да поддържа 100 000 потребители", -1);
	q4.AddOption("Системата трябва да може да се възстанови за 10 мин. след срив", -1);
	exam.push_back(q4);

	Question q5("UML клас диаграмата е диаграма, която:");
	q5.AddOption("Показва множество от класове на даден софтуер като определя и времето им за изпълнение", -1);
	q5.AddOption("Показва йерархията на класовете на даден софтуер", -1);
	q5.AddOption("Показва множество от класовете на даден софтуер, тяхното съдържание и връзките помежду им", 1);
	q5.AddOption("Показва множество от класовете на даден софтуер", -1);
	exam.push_back(q5);

	Question q6("Кои от изброените НЕ СА верни при тестването при гъвкавата методология ХР?\n(три верни отговора)");
	q6.AddOption("Тестването обикновено се извършва ръчно", 0.34);
	q6.AddOption("Клиентът не участва в процеса на тестване", 0.33);
	q6.AddOption("Тестовете са по-скоро базирани на програми", -1);
	q6.AddOption("Лесно може да се гарантира пълнотата на тестовете", 0.33);
	q6.AddOption("Тестовите случаи се създават преди разработването на кода", -1);
	exam.push_back(q6);

	Question q7("Софтуерът и хардуерът си приличат по това , че добро качество се постига при добър дизайн.");
	q7.AddOption("Истина", 1);
	q7.AddOption("Лъжа", -1);
	exam.push_back(q7);

	Question q8("Вградените софтуерни системи съставят са неразделна част от понятието за интернет на нещата(Internet of Things)");
	q8.AddOption("Истина", 1);
	q8.AddOption("Лъжа", -1);
	exam.push_back(q8);

	Question q9("Кои от изброените оказват най-силно влияние върху комуникацията в екипа\n(Три верни отговора)");
	q9.AddOption("Йерархията в екипа", -1);
	q9.AddOption("Complete Register Content", -1);
	q9.AddOption("Балансът между половете в екипа", 0.34);
	q9.AddOption("Опитността на екипа", 0.33);
	q9.AddOption("Големината на екипа", 0.33);
	exam.push_back(q9);

	Question q10("При т.нар. SOAP уеб услуги, различните функционалности на услугата се намират на един URL: ");
	q10.AddOption("Истина", -1);
	q10.AddOption("Лъжа", 1);
	exam.push_back(q10);

	Question q11("Кой е липсващият текст във фигурката на процеса на инженеринг на услуга(service engineering process)?\nImg not found");
	q11.AddOption("Service prioritization", -1);
	q11.AddOption("Service specification", -1);
	q11.AddOption("Service design", 1);
	exam.push_back(q11);

	Question q12("Кое от следните твърдения е вярно за диаграмите на последователност?");
	q12.AddOption("Представят UML диаграми, които имат за основна цел да покажат броя на разработчиците на системата", -1);
	q12.AddOption("Използват се за анализ на количеството използвана памет от системата", -1);
	q12.AddOption("Може да се показват взаимодействията между разработчиците на системата", -1);
	q12.AddOption("Показват последователността от взаимодействията между обектите", 1);
	exam.push_back(q12);

	Question q13("Кое от изброените не е един от 4-те сектора на всяко завъртане по спираловидния модел за разработване на софтуер?");
	q13.AddOption("Анализ на изискванията(Requirements engineering)", 1);
	q13.AddOption("Установяване на целите(Objective setting)", -1);
	q13.AddOption("Разработване и валидиране(Development and validation)", -1);
	q13.AddOption("Планиране(Planning)", -1);
	q13.AddOption("Оценка на риска(Risk assessment and reduction)", -1);
	exam.push_back(q13);

	Question q14("Кои от изброените са стандарти за качество на процес?");
	q14.AddOption("Планиране на тестване", -1);
	q14.AddOption("Одобрение на плана на проекта", 0.5);
	q14.AddOption("Форма за управление на промени", 0.5);
	q14.AddOption("Форма за тестови случаи", -1);
	exam.push_back(q14);

	Question q15("Кое от следните твърдения е вярно?");
	q15.AddOption("Моделът на бързата/стръмната разработка улеснява повторното използване на компоненти", -1);
	q15.AddOption("Прототипният модел улеснява повторното използване на компоненти", -1);
	q15.AddOption("Всички посочени твърдения са неверни", -1);
	q15.AddOption("И двата модела улесняват повторното използване на компоненти", 1);
	exam.push_back(q15);

	Question q16("Кое от изброените Е НЕФУНКЦИОНАЛНО изискване на приложната област?");
	q16.AddOption("Системата трябва да отговоря на закона за защита на личните данни.", 1);
	q16.AddOption("Системата трябва да е начилна в 95% от времето.", -1);
	q16.AddOption("Системата трябва да е лесно достъпна.", -1);
	q16.AddOption("Системата трябва да е написана на С++", -1);
	exam.push_back(q16);

	Question q17("Кое от следните характерно за т.нар. наследени(legacy) системи?");
	q17.AddOption("Разработени са чрез използването на съвременни технологии.", -1);
	q17.AddOption("Нито едно от изброените не е характерно за наследените системи", -1);
	q17.AddOption("За повечето разработчици е наказание да се занимават с тях, тъй като изискват доста усилия при поддръжката.", 1);
	q17.AddOption("Винаги съществува някакви валидна документация за тях", -1);
	exam.push_back(q17);

	Question q18("В диаграмите на последователност е възможно моделирането на условни преходи.");
	q18.AddOption("Истина", 1);
	q18.AddOption("Лъжа", -1);
	exam.push_back(q18);

	Question q19("Подредете задачите, които се извършват при управление на риска по подходящ начин/последователност\n1)Планиране\n2)Анализ\n3)Идентифициране\n4)Мониторинг");
	q19.AddOption("3,2,1,4", 1);
	q19.AddOption("3,2,4,1", -1);
	q19.AddOption("3,1,2,4", -1);
	exam.push_back(q19);

	Question q20("При поддръжката е задължително да се прави реверсивно инженерство на системата, за да се обърнат интерфейсите на класовете в системата според установените конвенции за писана на код в организацията.");
	q20.AddOption("Истина", 1);
	q20.AddOption("Лъжа", -1);
	exam.push_back(q20);

	Question q21("При т.нар. REST услуги, достъпът до различните функционалности се осъщестява според съобщението в заявката за изискване на услугата и се използва един и същи URL");
	q21.AddOption("Истина", 1);
	q21.AddOption("Лъжа", -1);
	exam.push_back(q21);

	Question q22("Управлението на качеството представлява независима проверка на процеса на разработване");
	q22.AddOption("Истина", 1);
	q22.AddOption("Лъжа", -1);
	exam.push_back(q22);

	Question q23("Гъвкавите софтуерни модели на процеси се наричат гъвкави, защото:");
	q23.AddOption("набляга на адаптивност", 0.5);
	q23.AddOption("елеминира нуждата от тежка документация", 0.5);
	q23.AddOption("широко използват създаването на прототипи", -1);
	q23.AddOption("не си губят времето за активности по планиране", -1);
	exam.push_back(q23);

	Question q24("SOAP/WSDL уеб услуги са по-олекотени от RESTful уеб услугите");
	q24.AddOption("Истина", -1);
	q24.AddOption("Лъжа", 1);
	exam.push_back(q24);

	Question q25("В кои от следните UML диаграми се използват класове и/или обекти");
	q25.AddOption("UML диаграма на състоянията", -1);
	q25.AddOption("UML диаграма на последователност", 0.5);
	q25.AddOption("UML клас диаграма", 0.5);
	q25.AddOption("UML диаграма на активностите", -1);
	exam.push_back(q25);

	Question q26("За кое от следните може да се твърди,че представлява софтуерен компонент?");
	q26.AddOption("Структурата от данни от тип списък", -1);
	q26.AddOption("Клас/Обект", -1);
	q26.AddOption("UML", -1);
	q26.AddOption("Шаблонът Singelton", -1);
	q26.AddOption("XML", -1);
	q26.AddOption("Клас/Обект, който реализира даден интерфейс", 1);
	exam.push_back(q26);

	Question q27("Кое от изброените НЕ Е предимство на гъвкавата методология Scrum");
	q27.AddOption("Клиентите могат да видят навременното доставяне на инкременти и да дадат своевременно препоръки", -1);
	q27.AddOption("Целият екин има видимост за всичко, което се случва при разработването", -1);
	q27.AddOption("Scrum master дефинира ясно изискванията", 1);	
	q27.AddOption("Продуктът е декомпозиран на малки лесни разбираеми части", -1);
	exam.push_back(q27);

	Question q28("Кои ои изброените НЕ СА характеристика на кохезионната група?");
	q28.AddOption("Отделният индивид е по-важен от групата", 0.5);
	q28.AddOption("Комуникацията винаги е формална", 0.5);
	q28.AddOption("Споделяне на знания и опит", -1); 
	q28.AddOption("Приемство в екипа", -1);
	exam.push_back(q28);

	Question q29("При системите за реално време най-малко значение има времето за което всеки процес(задача) в системата завършва своето изпълнение.");
	q29.AddOption("Истина", -1);
	q29.AddOption("Лъжа", 1);
	exam.push_back(q29);

	Question q30("Т.нар изправност(dependability) е способност на софтуера да предоставя функционалност, на която потребителите може да вярват.");
	q30.AddOption("Истина", 1);
	q30.AddOption("Лъжа", -1);
	exam.push_back(q30);

	Question q31("При кои от изброените дейности най-често могат да възникнат проблеми при прилагането на гъвкавите методологии");
	q31.AddOption("Дизайн", -1);
	q31.AddOption("Договаряне", 0.34);
	q31.AddOption("Поддръжка", 0.33);
	q31.AddOption("Имплементация", -1);
	q31.AddOption("Приоритизиране на промените", 0.33);
	q31.AddOption("Анализ на изискванията", -1);
	exam.push_back(q31);

	Question q32("Колко фази има при разработване по Скръм");
	q32.AddOption("Скръм е гъвкав метод, което означава, че в него няма фази", -1);
	q32.AddOption("Четири", -1);
	q32.AddOption("Три", 1);
	q32.AddOption("Два", -1);
	exam.push_back(q32);

	Question q33("Кои от изброените НЕ СА характерни за гъвкавите методологии");
	q33.AddOption("Готовност за промени", -1);
	q33.AddOption("Възможност за лесна поддръжка на продукта", 0.5);
	q33.AddOption("Активно включване на клиента", -1);
	q33.AddOption("Детайлен анализ на изискванията", 0.5);
	q33.AddOption("Итеративно и инкрементално разработване", -1);
	exam.push_back(q33);

	Question q34("Софтуерната архитектура се използва като: ");
	q34.AddOption("Средство за реклама на производителността на системата сред крайните потребители", -1);
	q34.AddOption("Инструмент за извличане на кода на системата от изискванията към нея", -1);
	q34.AddOption("Модел на системата", 0.5);
	q34.AddOption("Средство за комуникация между софтуерните инженери и последващ анализ на системата", 0.5);
	exam.push_back(q34);

	Question q35("Кой от следните модели НЕ Е подходящ за всякакви промяна?");
	q35.AddOption("Модел на водопада", 1);
	q35.AddOption("Модел на бързата/стръмната разработка", -1);
	q35.AddOption("Прототипен", -1);
	q35.AddOption("Спираловиден", -1);
	exam.push_back(q35);

	Question q36("Ако сте водещ разработчик в софтуерна фирма и трябва да предадете проект/продукт в рамките на определено време без ограничения в бюджета, кой модел на процес за разработване на софтуер ще изберете?");
	q36.AddOption("Модел на водопада", -1);
	q36.AddOption("Инкременталният модел", -1);
	q36.AddOption("Моделът на бързата/стръмната разработка", 1);
	q36.AddOption("Спираловидният модел", -1);
	exam.push_back(q36);

	Question q37("Кое от изброените НЕ Е стъпка при Управлението на промените при изискванията");
	q37.AddOption("Анализ на мнението на заинтересованите лица", 1);
	q37.AddOption("Анализ на промяната", -1);
	q37.AddOption("Анализ на проблема", -1);
	q37.AddOption("Анализ на цената", -1);
	exam.push_back(q37);

	Question q38("Спираловидният модел на софтуерен процес има високи изисквания за надежност");
	q38.AddOption("Истина", 1);
	q38.AddOption("Лъжа", -1);
	exam.push_back(q38);

	Question q39("Практически е невъзможно да се осигури висока надежност на софтуерните системи, които имат грешки в кода");
	q39.AddOption("Истина", 1);
	q39.AddOption("Лъжа", -1);
	exam.push_back(q39);

	Question q40("Спираловидният модел на софтуерен процес предвижда участие на потребителя във всичките му фази");
	q40.AddOption("Истина", -1);
	q40.AddOption("Лъжа", 1);
	exam.push_back(q40);

	Question q41("Кой от следните модели може да бъде избран, ако потребителят участва във всички фази от процеса на разработване на софтуера");
	q41.AddOption("Модела на бързата/стръмната разработка", -1);
	q41.AddOption("Модела на водопада", -1);
	q41.AddOption("Прототипния модел", -1);
	q41.AddOption("Нито един от посочените", 1);
	exam.push_back(q41);

	Question q42("Ladder диаграмите представляват специфичен програмен език, който наподобява код на С++");
	q42.AddOption("Истина", -1);
	q42.AddOption("Лъжа", 1);
	exam.push_back(q42);

	Question q43("Кои от изброените дейности НЕ включват участие на заинтересовани лица?(два верни отговора)");
	q43.AddOption("Прототипиране", -1);
	q43.AddOption("Потребителски случаи", 0.5);
	q43.AddOption("Интервюта", -1);
	q43.AddOption("Етнография", 0.5);
	q43.AddOption("Сценарии", -1);
	exam.push_back(q43);

	Question q44("Т. нар. междинно ниво(middleware) има за цел да управлява комуникацията между обектите.");
	q44.AddOption("Истина", 1);
	q44.AddOption("Лъжа", -1);
	exam.push_back(q44);

	Question q45("REST услугите НЕ СА реализация на Service oriented architecture(SOA).");
	q45.AddOption("Истина", -1);
	q45.AddOption("Лъжа", 1);
	exam.push_back(q45);

	Question q46("Можем да изградим Service oriented architecture(SOA) използвайки обектно ориентиран(ОО) език.");
	q46.AddOption("Истина", 1);
	q46.AddOption("Лъжа", -1);
	exam.push_back(q46);

	Question q47("Коя от следните се класифицира като динамична диаграма в UML?");
	q47.AddOption("Package diagram", -1);
	q47.AddOption("Classs diagram", -1);
	q47.AddOption("Sequence diagram", 1);
	q47.AddOption("Deployment diagram", -1);
	exam.push_back(q47);

	Question q48("Кое от следните НЕ Е метод за осигуряване на изправност(dependability) на системата?");
	q48.AddOption("Инспекции на кода", -1);
	q48.AddOption("Изплозване на механизми за изключения(exceptions) и обработката им", -1);
	q48.AddOption("Използване на формални спецификации и модели", -1);
	q48.AddOption("Разработване на готов прототип на всяка итерация", 1);
	exam.push_back(q48);

	Question q49("Кои от следните рискове ще се отразят И НА продукта И НА процеса?");
	q49.AddOption("Грешна преценка за обема на проекта", 0.34);
	q49.AddOption("Забавяне на спецификацията", 0.33);
	q49.AddOption("На пазара излиза силен конкурент", -1);
	q49.AddOption("Критични промени в изискванията", 0.33);
	q49.AddOption("Опитни хора напускат екипа преди края на проекта", -1);
	q49.AddOption("Промяна в мениджмънта на проекта", -1);
	exam.push_back(q49);

	Question q50("За коя от следните групи НЕ СА предназначени системните изисквания?");
	q50.AddOption("Технолози при клиента", -1);
	q50.AddOption("Разработчици", -1);
	q50.AddOption("Клиенти", 1);
	q50.AddOption("Системни архитекти", -1);
	exam.push_back(q50);

	Question q51("Компютърните системи обикновенно са много скъпи, защото:");
	q51.AddOption("Лицензите на системния софтуер са много скъпи.", -1);
	q51.AddOption("Създаването на софтуер е процес, който изисква значителни усилия.", 1);
	q51.AddOption("Хардуерът на компютъра е много скъп.", -1);
	q51.AddOption("Разработчиците на софтуер си добавят прекалена печалба към разходите.", -1);
	exam.push_back(q51);

	Question q52("Коя от изброените НЕ Е допълнителна рамкова дейност от софтуерния процес?");
	q52.AddOption("Управление на риска", -1);
	q52.AddOption("Следене и управление на софтуерния проект", -1);
	q52.AddOption("Измерване", -1);
	q52.AddOption("Планиране", 1);
	exam.push_back(q52);

	Question q53("Кое от следните твърдения е причина думата ИНЖЕНЕРСТВО да е част от термина СОФТУЕРНО ИНЖЕНЕРСТВО?");
	q53.AddOption("Разработването на софтуер се поддържа от математически и научни принципи по начин, подобен на този при конвенционален инженерен продукт.", -1);
	q53.AddOption("Разработването на софтуер включва анализ на изискванията, проектиране, реализиране и тестване както създаването на конвенционален инженерен продукт.", 1);
	q53.AddOption("Разработването на софтуер зависи от хардуера, създаден от инженерите по електроника.", -1);
	q53.AddOption("Софтуерните системи страдат от infant mortality повреди и wear-out повреди, също като конвенционалните продукти, които се създават.", -1);
	exam.push_back(q53);

	Question q54("Кое от изброените НЕ Е предимство при програмирането по двойки(pair programming)?");
	q54.AddOption("Повишава скоростта на разработване.", 1);
	q54.AddOption("Създава общо знание за кода в екипа.", -1);
	q54.AddOption("Служи като неформален ревю процес.", -1);
	q54.AddOption("Може да бъде използвано за обучение.", -1);
	exam.push_back(q54);

	Question q55("В стилът неявно извикване(implicit invocation), компонентите взаимодействат помежду си чрез:");
	q55.AddOption("Извикване на метод, при което изпращащият компонент изчаква за отговор, преди да продължи със своето изпълнение.", -1);
	q55.AddOption("Изпращане на т.нар. събития, при които изпращащият компонент не знае нищо за получателя.", 1);
	q55.AddOption("Изпращане на т.нар. събития, при които изпращащият компонент има информация за получателя.", -1);
	exam.push_back(q55);

	Question q56("Подръжката на софтуера се смята за важен атрибут на качествения софтуер,защото:");
	q56.AddOption("През жизнения цикъл на софтуера в много случаи повече пари се отделят за поддръжка,от колкото за първоначалното разработване на софтуера.", 1);
	q56.AddOption("Потребителите никога не могат да решават какво точно искат софтуера да прави.", -1);
	q56.AddOption("Повечето от хората,които първоначално са разработвали софтуера са се преместили да рабоят по други проекти.", -1);
	q56.AddOption("Развитието на програмните езици води до липса на експертиза в по-старите програмни езици.", -1);
	exam.push_back(q56);

	Question q57("Изискванията,които се променят,поради промени в средата,в която работи организацията се наричат:");
	q57.AddOption("Последстващи изисквания.", -1);
	q57.AddOption("Съвместими изисквания.", -1);
	q57.AddOption("Появяващи се изисквания.", -1);
	q57.AddOption("Мутиращи изисквания.", 1);
	exam.push_back(q57);

	Question q58("Кои от изброените НЕ СА цели на UML?");
	q58.AddOption("Да се създаде използваем език за хора и машини.", -1);
	q58.AddOption("Да се дефинира run-time модел.", -1);
	q58.AddOption("Независимост от програмните езици и технологии.", -1);
	q58.AddOption("Да предостави средства за управление на процеса на разработване.", 1);
	exam.push_back(q58);

	Question q59("По-голяма част от софтуера все още продължава да се разработва от организацията вместо да се използват компоненти за многократна употреба,защото:");
	q59.AddOption("Повторното използване на компоненти е обшо прието в света на софтуера.", -1);
	q59.AddOption("Софтуерът се разработва по-лесно без да се използват компоненти на друга организация.", -1);
	q59.AddOption("Става все по-трудно да се поръчат резервни части/компоненти за софтуера.", 1);
	q59.AddOption("Компонентите за многократна употреба са твърде скъпи,за да се използват.", -1);
	exam.push_back(q59);

	Question q60("Кои от следните твърдения са верни за софтуерната архитектура?");
	q60.AddOption("Добра практика е моделът на софтуерната архитектура да се направи след като е приключила реалзацията на сиситемата.", -1);
	q60.AddOption("Въпреки че е полезна за комуникация в екипа по разработка на системата,софтуерната архитектура затруднява многократната употреба на компонентите.", -1);
	q60.AddOption("Резултат е от фазата на дизайн в процеса за разработка на софтуерни системи.", 0.5);
	q60.AddOption("Софтуерната архитектура не зависи от изискванията към системата.", -1);
	q60.AddOption("Съществени елементи на модулната структура на архитектурата са не само компонентите, които носят функционалността,но и свързващите ги модули.", 0.5);
	exam.push_back(q60);

	Question q61("Кои от следните се класифицират като елементарен тип данни в езиците за програмиране?");
	q61.AddOption("byte", 0.5);
	q61.AddOption("Съставен оператор", -1);
	q61.AddOption("String", -1);
	q61.AddOption("Object", -1);
	q61.AddOption("int", 0.5);
	exam.push_back(q61);

	Question q62("Кой от следните типове личности би отговорил най-добре на даденето изискване:Търси се Scrum Master.Необходими са добри комуникативни умения,както за активна работа с клиенти така и за подобряване на колаборацията вътре в екипа.");
	q62.AddOption("Ориентиран към задачи.", -1);
	q62.AddOption("Ориентиран към себе си", -1);
	q62.AddOption("Ориентиран към взаимодействия.", 1);
	exam.push_back(q62);

	Question q63("Софтуерна валидация се постига чрез серия от тестове,извършени от потребителя след като софтуера е внедрен в неговата работна среда.");
	q63.AddOption("Истина", -1);
	q63.AddOption("Лъжа", 1);
	exam.push_back(q63);

	Question q64(" В диаграмите на последователност(sequence) НЕ СЕ допуска моделирането на цикли.");
	q64.AddOption("Истина", -1);
	q64.AddOption("Лъжа", 1);
	exam.push_back(q64);

	Question q65("Основни функции на архитектурата,ориентирана към услуги са откриване на услуги,публикуване на услуги и разпознаване на протокола за свързване с услугата");
	q65.AddOption("Истина", 1);
	q65.AddOption("Лъжа", -1);
	exam.push_back(q65);

	Question q66("За кой от изброените архитектурни стилове се счита,че е най-масово използван в софтуерните системи?");
	q66.AddOption("Хранилище", -1);
	q66.AddOption("Многослоен", 1);
	q66.AddOption("Канал-филтър", -1);
	q66.AddOption("Неявно извикване", -1);
	exam.push_back(q66);

	Question q67("Кои от изброените дейности са основни при управлението на проекти(два отговора)?");
	q67.AddOption("Управление на хората", 0.5);
	q67.AddOption("Управление на качеството", -1);
	q67.AddOption("Управление на изискванията", -1);
	q67.AddOption("Отчитане на проекта", 0.5);
	exam.push_back(q67);

	Question q68("Гъвкавите софтуерни модели на процеси се наричат гъвкави ,защото:");
	q68.AddOption("Широко използват създаването на прототипи.", -1);
	q68.AddOption("Наблягат на адаптивност.", 0.5);
	q68.AddOption("Елиминират нуждата от тежка документация.", 0.5);
	q68.AddOption("Не си губят времето за активности по пламиране.", -1);
	exam.push_back(q68);

	Question q69("Създаването на прототип рано в процеса на разработването на софтуер е смята за добра идея,защото спомага:");
	q69.AddOption("Намалява цената на разработване.", -1);
	q69.AddOption("Валидиране на нефункционалните изисквания.", -1);
	q69.AddOption("Определяне на нуждите на крайния потребител.", -1);
	q69.AddOption("Специфициране на софтуерните компоненти.", 1);
	exam.push_back(q69);

	Question q70("Архитектурният стил хранилище,НЕ СЕ характеризира с:");
	q70.AddOption("Благоприятства сигурността.", -1);
	q70.AddOption("Всеки модул в системата предава данните в строго определен ред към следващия.", 1);
	q70.AddOption("Лесно се реализира разпределеност на данните.", -1);
	q70.AddOption("Ефективност при обмен на големи количествени данни.", -1);
	exam.push_back(q70);

	unsigned questionsCount = exam.size();
	for (unsigned i = 0; i < questionsCount; ++i)
		std::swap(exam[Randomize(exam.size())], exam[Randomize(exam.size())]);
	for (unsigned i = 0; i < exam.size(); ++i)
	{
		if (i == questionsCount)
		{
			std::cout << "Секция със сгрешени въпроси\nнатисни някой бутон\n";
			std::cin >> useless;
			system("CLS");
		}
		std::cout << 1 + i << '/' << exam.size() << '\n';
		exam[i].AskQuestion();
		if (exam[i].AnswerQuestion() != 1 && !flag)
			exam.push_back(exam[i]);
		std::cin >> useless;
		system("CLS");
	}
	std::cout << "Това беше само началото!\nТвоят резултат е: " << counter << '/' << exam.size();
	std::cin >> useless;
	system("pause");
	return 0;
}