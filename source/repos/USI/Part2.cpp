#include<iostream>
#include<Windows.h>
#include <cstdlib>
#include <vector>
#include <ctime>
#include <algorithm>
#include <string>
unsigned counter = 0;
struct Option
{
	Option(const std::string&, const double);
	double val = 0;
	std::string text;
};
Option::Option(const std::string& txt, const double val) : text(txt), val(val)
{
}
class Question
{
public:
	Question(const std::string&);
	void AddOption(const std::string&, const double);
	void AskQuestion();
	int AnswerQuestion();
private:
	std::string m_Question;
	std::vector<Option>m_Answers;
	double m_Score = 0;
};
void Question::AddOption(const std::string& rhs, const double val)
{
	Option opt(rhs, val);
	m_Answers.push_back(opt);
}
Question::Question(const::std::string& task) : m_Question(task)
{
}
int Randomize(const int i)
{
	return std::rand() % i;
}
void Question::AskQuestion()
{
	std::cout << m_Question << "\n\n";
	std::srand(unsigned(std::time(0)));
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		std::swap(m_Answers[Randomize(m_Answers.size())], m_Answers[Randomize(m_Answers.size())]);
	for (unsigned i = 0; i < m_Answers.size(); ++i)
	{
		char ind = i + 65;
		std::cout << ind << ' ' << m_Answers[i].text << '\n';
	}
}

int Question::AnswerQuestion()
{
	char tmp = 'v';
	unsigned tmpToInt;
	std::cin >> tmp;
	tmpToInt = tmp;
	do
	{
		if (tmpToInt < 97)
			tmpToInt -= 65;
		else
			tmpToInt -= 97;
		m_Score += m_Answers[tmpToInt].val;
		std::cin >> tmp;
		tmpToInt = tmp;
	} while (tmp != 's' && tmp != 'S');
	std::cout << "Резултат: " << m_Score << "\nВерен отговор(i): ";
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		if (m_Answers[i].val > 0)
			std::cout << char(i + 65) << ' ';
	std::cout << "\nВъведи някой символ";
	if (m_Score > 0)
		counter++;
	return m_Score;
}
int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	std::cout << "Подготовка за изпит по УСИ\nИзготвен от Д.К.,кодът е от Mapmo, Dakata, Ikbal i M.\n";
	std::cout << "За да отговорите на някой въпрос въведете буквата(буквите) и когато сте готови въведете 's'\n";
	std::cout << "Съобразете се как работи std::cin\nАко желаете симулация без повторни въпроси въведете r\nАко желаете въпросите, които сте объркали да се запазват натиснете произволен бутон\n";
	char useless;
	std::cin >> useless;
	bool flag = (useless == 'r' ? 1 : 0);
	system("CLS");
	std::vector<Question> exam;
	std::srand(unsigned(std::time(0)));

	Question q1("Каква е целта на дизайна на софтуерни системи?");
	q1.AddOption("Да усложни разработката на софтуер.", -1);
	q1.AddOption("Да се планират дейностите по  разработката на системата,като в резултат на това може да се променят изискванията.", 1);
	q1.AddOption("Да се планират дейностите по разработката на системата,като не се променят изискванията. ", -1);
	q1.AddOption("Да създаде повече работни места.", -1);
	exam.push_back(q1);

	Question q2(" При кои от изброените дейности най-често могат да възникнат проблеми при прилагането на гъвкавите методологии? (3 верни отговора) ");
	q2.AddOption("Имплементация.", -1);
	q2.AddOption("Приоритизиране на промените.", 0.34);
	q2.AddOption("Дизайн.", -1);
	q2.AddOption("Анализ на изискванията.", -1);
	q2.AddOption("Договаряне.", 0.33);
	q2.AddOption("Поддръжка.", 0.33);
	exam.push_back(q2);

	Question q3(" Т.нар. изправност (dependability) на софтуера е способност на софтуера да предоставя функционалност, на която потребителите може да вярват. ");
	q3.AddOption("Истина", 1);
	q3.AddOption("Лъжа", -1);
	exam.push_back(q3);

	Question q4("Диаграмите на състоянията (State chart) представляват граф, като възлите на графа моделират различни потребители на системата, а дъгите - събитията, които водят до преход от едно състояние до друго. ");
	q4.AddOption("Истина", -1);
	q4.AddOption("Лъжа", 1);
	exam.push_back(q4);

	Question q5("Кое от изброените НЕ Е техника за извличане на изискванията? ");
	q5.AddOption("Етнография.", -1);
	q5.AddOption("Ревюта на изискванията.", 1);
	q5.AddOption("Интервюта.", -1);
	q5.AddOption("Потребителски случаи.", -1);
	exam.push_back(q5);

	Question q6(" Кое от следните твърдения е вярно по отношение на понятието за компонентен модел?");
	q6.AddOption("Компонентния модел дефинира стандарт за интерфейсите на компонентите.", 1);
	q6.AddOption("Компонентияни модел не може да се използва при разпределени софтуерни системи.", -1);
	q6.AddOption("Нито едно от посочените не е вярно.", -1);
	q6.AddOption("Компонентиният модел не може да се използва при вградени софтуерни системи.", -1);
	exam.push_back(q6);

	Question q7("Към коя от категориите може да бъде причислен рискът “Промяна на изискванията”?");
	q7.AddOption("Рискове на проекта и продукта.", 1);
	q7.AddOption("Рискове на проекта.", -1);
	q7.AddOption("Рискове на продукта.", -1);
	q7.AddOption("Бизнес рискове.", -1);
	exam.push_back(q7);

	Question q8("Кои от следните понятия може да се класифицират като подходи за многократна употреба в софтуерното инжинерство? (2 верни отговора)");
	q8.AddOption("Екстремно програмиране.", -1);
	q8.AddOption("Аспектно-ориентирано разработване.", 0.5);
	q8.AddOption("Архитектура, ориентирана към услуги.", 0.5);
	q8.AddOption("Използване на вградени системи.", -1);
	exam.push_back(q8);

	Question q9("Статичния автоматичен анализ може да открие програмни аномалии, които да са индикация за грешки в кода.");
	q9.AddOption("Истина.", 1);
	q9.AddOption("Лъжа.", -1);
	exam.push_back(q9);

	Question q10("Еволюционните модели на разработка на софтуер са:");
	q10.AddOption("Итеративни по своята същност.", 1);
	q10.AddOption("Всичките горни отговори.", -1);
	q10.AddOption("Може лесно да се приспособят към промени в изискванията към продукта.", -1);
	q10.AddOption("По принцип не създават системи за изхвърляне.", -1);
	exam.push_back(q10);

	Question q11("Ladder диаграмите представляват специфичен програмен език, за реализация на вградени системи за управление на технологични процеси.");
	q11.AddOption("Истина.", 1);
	q11.AddOption("Лъжа.", -1);
	exam.push_back(q11);

	Question q12("Коя от изброените НЕ Е обща рамкова дейност /generic process framework activity/?");
	q12.AddOption("Внедряване.", -1);
	q12.AddOption("Моделиране.", -1);
	q12.AddOption("Комуникация.", -1);
	q12.AddOption("Осигуряване на качеството на софтуера.", 1);
	exam.push_back(q12);

	Question q13("Процесът при който група хора щателно изследва част или цялата софтуерна система и съпътстваща я документация се нарича:");
	q13.AddOption("Тестване", -1);
	q13.AddOption("Управление на процеса", -1);
	q13.AddOption("Верификация", -1);
	q13.AddOption("Ревю ", 1);
	exam.push_back(q13);

	Question q14("Една от разликите между аспект и компонент е, че при първия вид елементи липсва описание на интерфейси.");
	q14.AddOption("Истина", 1);
	q14.AddOption("Лъжа", -1);
	exam.push_back(q14);

	Question q15("При осигуряването на качеството на софтуера няма разлика между софтуерана верификация и софтуерна валидация.");
	q15.AddOption("Истина", -1);
	q15.AddOption("Лъжа", 1);
	exam.push_back(q15);

	Question q16("Кои от следните са характеристики на вградените софтуерни системи? (посочете до 4 верни отговора)");
	q16.AddOption("Неограничени системни ресурси.", -1);
	q16.AddOption("Обикновено имат дълъг период на употреба.", 0.25);
	q16.AddOption("Ограничени системни ресурси.", 0.25);
	q16.AddOption("Необходимо е да се спазват гъвкави методологии за разработка на софтуер.", -1);
	q16.AddOption("Проверката за грешки и тестването на системата е лесно.", -1);
	q16.AddOption("За реализацията им може да се използват програмни езици от ниско ниво.", 0.25);
	q16.AddOption("Понякога се налага съвместен дизайн на софтуера и хардуера. ", 0.25);
	exam.push_back(q16);

	Question q17("Кое от следните НЕ е пример за вградена софтуерна система?");
	q17.AddOption("Софтуер за управление на температурата в складово помещение.", -1);
	q17.AddOption("Софтуер за управление на режимите на двигателя на перална машина.", -1);
	q17.AddOption("Софтуер за осчетоводяване на наличностите в складово помещение.", 1);
	q17.AddOption("Софтуер за управление на движението на вратата на складово помещение.", -1);
	exam.push_back(q17);

	Question q18("Кой е най-разпространенията език за създаване на графични модели на софтуерни системи?");
	q18.AddOption("IDL", -1);
	q18.AddOption("Java", -1);
	q18.AddOption("UML", 1);
	q18.AddOption("UDDI", -1);
	q18.AddOption("XML", -1);
	exam.push_back(q18);

	Question q19("С кой от изброените вътрешни атрибути не е свързана вътрешната характеристика за възможност за поддръжка?");
	q19.AddOption("Големина на програмата в линии код.", -1);
	q19.AddOption("Дълбочина на дървото на наследяване.", -1);
	q19.AddOption("Цикломатична сложност/комплесност.", -1);
	q19.AddOption("Броят съобщения за грешка.", 1);
	exam.push_back(q19);

	Question q20("Structured text е специфичен програмен език за реализация на вградени системи, който наподобява Паскал.");
	q20.AddOption("Истина", 1);
	q20.AddOption("Лъжа", -1);
	exam.push_back(q20);

	Question q21("Допълнителните рамкови дейности на софтуерното инженерство се прилагат само по време на началните фази от процеса  на разработване на софтуер?");
	q21.AddOption("Истина", -1);
	q21.AddOption("Лъжа", 1);
	exam.push_back(q21);

	Question q22("Коя от изброените не е допълнителна рамкова дейност от софтуерния процес?");
	q22.AddOption("Планиране", 1);
	q22.AddOption("Управление", -1);
	q22.AddOption("Измерване", -1);
	q22.AddOption("Следене и управление на софтуерния продукт", -1);
	exam.push_back(q22);

	Question q23("Софтуерна система е почти завършена, когато се открива грешка. Цената за корегиране на грешката ще бъде най-висока, ако грешката е направена по време на: ");
	q23.AddOption("Имплементацията", -1);
	q23.AddOption("Софтуерно проектиране", -1);
	q23.AddOption("Софтуерната спецификация", -1);
	q23.AddOption("Дефиниране на изискванията", 1);
	exam.push_back(q23);

	Question q24("За кой от следните случаи се казва, че е подходящо да се прилага аспектно-ориентирано програмиране?");
	q24.AddOption("Във всички посочени случаи", -1);
	q24.AddOption("При обработка на големи масиви ит данни", -1);
	q24.AddOption("При необходимост от реализиране на сложни алгоритми", -1);
	q24.AddOption("При реализиране алгоритъм за криптиране на данни, общ за цялата система", 1);
	exam.push_back(q24);

	Question q25("Какво включва документацията на софтуерната архитектура?");
	q25.AddOption("Описание на интерфейсите на компонентите в системата", -1);
	q25.AddOption("Всички посочени са верни", 1);
	q25.AddOption("Машини на състояниято(state charts, графи)", -1);
	q25.AddOption("Диаграма от тип 'кутийки и линии'(box-and-lines)", -1);
	exam.push_back(q25);

	Question q26("За кое от следните може да се твърди, че представлява софтуерен компонент?");
	q26.AddOption("Клас/Обект, който реализира даден интерфейс", 1);
	q26.AddOption("XML", -1);
	q26.AddOption("Структура от данни тип списък", -1);
	q26.AddOption("UML", -1);
	q26.AddOption("Клас/Обект", -1);
	q26.AddOption("Шаблонът Singelton", -1);
	exam.push_back(q26);

	Question q27("Кое от изброените НЕ Е дейност при управлението на качеството?");
	q27.AddOption("Специфициране на качеството", 1);
	q27.AddOption("Контрол по качеството", -1);
	q27.AddOption("Планиране на качеството", -1);
	q27.AddOption("Осигуряване на качеството", -1);
	exam.push_back(q27);

	Question q28("При гъвкавите софтуерни процеси, най-високият приоритет е да се удовлетвори клиента, чрез ранно и непрекъснато доставяне на ценен (valued) софтуер?");
	q28.AddOption("Истина", 1);
	q28.AddOption("Лъжа", -1);
	exam.push_back(q28);

	Question q29("Кое не е дейност при управлението на риска?");
	q29.AddOption("Анализ на риска", -1);
	q29.AddOption("Идентифициране на риска", -1);
	q29.AddOption("Планиране на риска", -1);
	q29.AddOption("Контрол на риска", 1);
	exam.push_back(q29);

	Question q30("Моделът на бързата/стръмната разработка е?");
	q30.AddOption("Полезен подход, когато клиентът не може да дефинира ясно изискванията си", -1);
	q30.AddOption("Висоскоростна адаптация на линейния последователен модел", 1);
	q30.AddOption("Всички посочени отговри са верни", -1);
	q30.AddOption("Друго име на компонентно-базираното разработване", -1);
	exam.push_back(q30);

	Question q31("Системита за реално време със синхронно диспечизиране се характеризират с:");
	q31.AddOption("Висока предсказуемост и ниска реактивност", 1);
	q31.AddOption("Ниска предсказуемост и висока реактивност", -1);
	q31.AddOption("Ниска предсказуемост и ниска реактивност", -1);
	q31.AddOption("Висока предсказуемост и висока реактивност", -1);
	exam.push_back(q31);

	Question q32("Операционните системи за реално време задължително имат следните функции:");
	q32.AddOption("Регистрация на външни събития ", 0.5);
	q32.AddOption("Синхронизация и комуникация на процесите", 0.5);
	q32.AddOption("Управление на правата за достъп до данните", -1);
	q32.AddOption("Осигуряване на излишък от ресурси", -1);
	exam.push_back(q32);

	Question q33("Кое от изброените НЕ Е част от плана на качеството?");
	q33.AddOption("Описание на изискванията към продукта", 1);
	q33.AddOption("Кратко описание на продукта", -1);
	q33.AddOption("Рискове и управление на риска", -1);
	q33.AddOption("Описание на процеса", -1);
	exam.push_back(q33);

	Question q34("Софтуерът се влошава, а не се износва защото:");
	q34.AddOption("Много заявки за промени въвеждат грешки при взаимодействието на отделните компоненти", 1);
	q34.AddOption("Дефектите е по-вероятно да възникнат след като софтуерът се е използвал често", -1);
	q34.AddOption("Софтуерът страда от излагане във враждебна среда", -1);
	q34.AddOption("Става все по-трудно да се поръчат резервни части компоненти за софтуера", -1);
	exam.push_back(q34);

	Question q35("Тестването на системата е достатъчно, за да се гарантира нейната надеждност?");
	q35.AddOption("Истина", -1);
	q35.AddOption("Лъжа", 1);
	exam.push_back(q35);

	Question q36("Създаването на софтуер чрез еволюционен прототип включва?");
	q36.AddOption("Създаване на нова версия на софтуера на всяка фаза от разработването, която включва софтуер, създаден по време на предишната фаза", 1);
	q36.AddOption("Създаване на нова версия на софтуера на всяка фаза от разработването, която не включва никакъв софтуер, създаден по време на предишната фаза", -1);
	q36.AddOption("Създаване на версия на софтуера, която се използва за оценка на потрепителския интерфейс", -1);
	q36.AddOption("Създаване на версия на софтуера, която се използва за тестване на осъществимостта на метод с цел адресиране на нефункционалните изисквания на системата", -1);
	exam.push_back(q36);

	Question q37("Кои твърдения НЕ СА верни?");
	q37.AddOption("Инспекциите могат да проверяват нефункционални изисквания.", 0.5);
	q37.AddOption("Инспекциите могат да докажат съвместимост с реални очаквания на клиента.", 0.5);
	q37.AddOption("Инспекциите и тестването взаимно се допълват като техники за верификация.", -1);
	q37.AddOption("И инспекциите и тестването трябва да бъдат използвани по време на В&В процеса.", -1);
	exam.push_back(q37);

	Question q38("Коя от изброените дейности НЕ Е основна при инженеринга на изискванията:");
	q38.AddOption("Валидиране на изискванията.", -1);
	q38.AddOption("Идентифициране на изискванията.", -1);
	q38.AddOption("Управление на изискванията.", -1);
	q38.AddOption("Анализ на изискванията.", -1);
	q38.AddOption("Класификация на изискванията.", 1);
	exam.push_back(q38);

	Question q39("Кое от следните е вярно при т.нар. плътен (fat) клиент?");
	q39.AddOption("Представянето на данните и логиката на приложението се намират при клиента.", 1);
	q39.AddOption("Представянето и управлението на данните се извършват при клиента.", -1);
	q39.AddOption("Представянето и управлението на данните се извършват при сървъра.", -1);
	q39.AddOption("Управлението на данните и логиката на приложението се намират при сървъра.", -1);
	exam.push_back(q39);

	Question q40("Идеята за междинното ниво (в разпределените системи) е въведена за:");
	q40.AddOption("Улесняване на комуникация между обекти, които работят на различни машини.", 1);
	q40.AddOption("Изготвяне на по-разбираема софтуерна архитектура.", -1);
	q40.AddOption("Намаляване на документацията на системата", -1);
	q40.AddOption("Увеличаване на производителността на системата", -1);
	exam.push_back(q40);

	Question q41("За коя от изброените групи не са предназначени системните изисквания?");
	q41.AddOption("Клиенти", 1);
	q41.AddOption("Системни архитекти", -1);
	q41.AddOption("Разработчици", -1);
	q41.AddOption("Технолози при клиента", -1);
	exam.push_back(q41);

	Question q42("Ако трябва да опишете взаимодействието между различните обекти в системата по отношение на времето, каква диаграма бихте използвали?");
	q42.AddOption("UML диаграма на последователност (sequence)", 1);
	q42.AddOption("UML диаграма на състоянията(state chart)", -1);
	q42.AddOption("UML диаграма на потребителските случаи(use case)", -1);
	q42.AddOption("UML клас(class) диаграма", -1);
	exam.push_back(q42);

	Question q43("Кои от тези стратегически въпроси трябва да се адресират при успешен процес на тестване на софтуер?");
	q43.AddOption("Да се използват независими екипи за тестване.", 0.5);
	q43.AddOption("Да се специфицират изискванията по количествено измерим начин.",0.5 );
	q43.AddOption("Да се извършват формални технически прегледи преди тестването.", -1);
	q43.AddOption("Да се изчака кодът да се напише, преди да се напишат тестовите планове.", -1);
	exam.push_back(q43);

	Question q44("Тестване, което цели да изпита системата отвъд максималното натоварване по дизайн и да предизвика срив на системата се нарича?");
	q44.AddOption("Стрес тестване", 1);
	q44.AddOption("Тестване на капацитета", -1);
	q44.AddOption("Натоварващо тестване", -1);
	q44.AddOption("Тестване на производителност", -1);
	q44.AddOption("Тестване на интерфейс", -1);
	exam.push_back(q44);

	Question q45("Практически не е възможно да се разработят софтуерни системи, в които не съществуват грешки в кода (бъгове)?");
	q45.AddOption("Истина", 1);
	q45.AddOption("Лъжа", -1);
	exam.push_back(q45);

	Question q46("Кои от изброените НЕ СА верни при тестването при гъвкавата методология ХР? (три верни отговора)?");
	q46.AddOption("Клиента не участва в процеса на тестване.", 0.34);
	q46.AddOption("Тестовите случаи се създават преди разработването на кода.", -1);
	q46.AddOption("Тестването обикновено се извършва ръчно.", 0.33);
	q46.AddOption("Тестовете са по-скоро базирани на програми.", -1);
	q46.AddOption("Лесно може да се гарантира пълнота на тестването.", 0.33);
	exam.push_back(q46);

	Question q47("Прототипният модел на разработване на софтуер е:");
	q47.AddOption("Полезен подход, когато клиентът не може да дефинира ясно изискванията си.", 1);
	q47.AddOption("Най-добрия подход, който може да се използва за проекти с големи разработващи екипи.", -1);
	q47.AddOption("Рисков модел, който рядо създава значими/смислени продукти.", -1);
	q47.AddOption("Разумен подход, когато изискванията са добре дефинирани.", -1);
	exam.push_back(q47);

	Question q48("Функционално изискване към софтуерната система е:");
	q48.AddOption("Детайлно твърдение за поведението на системата от гледна точка на крайния потребител.", 1);
	q48.AddOption("Твърдение за това как софтуерната система да се реализира.", -1);
	q48.AddOption("Твърдение за практическо ограничение, наложено върху системата.", -1);
	q48.AddOption("Общо твърдение на това, какво софтуерната система трябва да постигне.", -1);
	exam.push_back(q48);

	Question q49("Кое от изброените НЕ Е характерно за неформалните групи/екипи?");
	q49.AddOption("Има ясна йерархична структура.", 1);
	q49.AddOption("Лидерът служи като интерфейс с външния свят.", -1);
	q49.AddOption("Задачите се разпределят в зависимост от способностите и опита.", -1);
	q49.AddOption("Екипът взема решения с консенсус.", -1);
	exam.push_back(q49);

	Question q50("Моделно-ориентираната разработка е:");
	q50.AddOption("По-високо ниво на абстракция.", 0.5);
	q50.AddOption("Подход, при който кодът на програмиране се пише от високо квалифицирани разработчици.", -1);
	q50.AddOption("Подход, при който основния резултат от разработката са модели.", 0.5);
	q50.AddOption("Подход, при който разходите за разработка на поддържащи инструменти са ниски.", -1);
	exam.push_back(q50);

	Question q51("За какво се използва протоколът SOAP при уеб-услугите?");
	q51.AddOption("Нито едно от изброените по-горе не е вярно.", -1);
	q51.AddOption("За достъп до функционалността на услугата.", 1);
	q51.AddOption("За откриване на местоположението на услугата.", -1);
	q51.AddOption("За промяна на функционалността на услугата.", -1);
	exam.push_back(q51);

	Question q52("При кой от следните модели на софтуерен процес времето до възможността за обратна връзка от клиента е най-бързо?");
	q52.AddOption("Еволюционен модел.", 1);
	q52.AddOption("Инкрементален модел.", -1);
	q52.AddOption("Метод на формалните трансформации.", -1);
	q52.AddOption("Модел на водопада.", -1);
	exam.push_back(q52);

	Question q53("Вградените софтуерни системи се реализират и изпълняват върху програмируеми логически контролери но не и върху едночипови микрокомпютри?");
	q53.AddOption("Истина", -1);
	q53.AddOption("Лъжа", 1);
	exam.push_back(q53);

	Question q54("Кое от следните не се класифицира като е диаграма на поведението в UML?");
	q54.AddOption("Activity diagram", -1);
	q54.AddOption("Class diagram", 1);
	q54.AddOption("State chart diagram", -1);
	q54.AddOption("Sequence diagram", -1);
	exam.push_back(q54);

	Question q55("За кои от изброените понятия се счита че осъществяват многократната употреба в обектно-ориентирания дизайн?");
	q55.AddOption("Наследяване", 1);
	q55.AddOption("Верификация", -1);
	q55.AddOption("Енкапсулация", -1);
	q55.AddOption("Използването на публични атрибути", -1);
	exam.push_back(q55);

	Question q56("Кои от избоените НЕ СА верни за управлението на качеството?");
	q56.AddOption("При по-малки системи управлението на качеството се фокусира повече върху документацията, отколкото върху установяване на култура на качеството.", 0.5);
	q56.AddOption("Установяването на стандарти и практики за управление на качеството в организацията започва със стартирането на конкретен проект.", 0.5);
	q56.AddOption("Документацията на качеството поддържа непрекъснатостта на разработването, дори и при смяна на разработващия екип.", -1);
	q56.AddOption("Управлението на качеството представлява независима проверка на процеса на разработване.", -1);
	exam.push_back(q56);

	Question q57("Кои от следните фактори са най-важни при управлението на хора?(4 верни отговора)");
	q57.AddOption("Консистентност", 0.25);
	q57.AddOption("Включване", 0.25);
	q57.AddOption("Честност", 0.25);
	q57.AddOption("Уважение", 0.25);
	q57.AddOption("Взаимодействие", -1);
	q57.AddOption("Качество", -1);
	exam.push_back(q57);

	Question q58("Кои от изброените са характерни за Sprint цикъла при гъвкавата методология Scrum?\n");
	q58.AddOption("Като основа за планирането на Sprint цикъла се използва списък с изисквания.", -1);
	q58.AddOption("Екипът е изолиран от клиента по време на разработката.", 0.5);
	q58.AddOption("Изборът на функционалности, които да се разработят се прави от клиента и Scrum master.", -1);
	q58.AddOption("Sprint цикъла има фиксирана дължина от 2 до 4 седмици", 0.5);
	exam.push_back(q58);

	Question q59("Кое от изброените НЕ Е предимство на гъвкавата методология Scrum?");
	q59.AddOption("Scrum master дефинира ясно изискванията.", 1);
	q59.AddOption("Продуктът е декомпозиран на малки лесно разбираеми части.", -1);
	q59.AddOption("Клиентите могат да видят навременното доставяне на инкременти и да дадат своевременно препоръки.", -1);
	q59.AddOption("Целият екип има видимост за всичко, което се случва при разработване.", -1);
	exam.push_back(q59);

	Question q60("Кои две от изброените UML диаграми са най-подходящи за представяне на взаимодействието на системата с околната и среда (потребители и други системи)?");
	q60.AddOption("Sequence diagram", 0.5);
	q60.AddOption("Use case diagram", 0.5);
	q60.AddOption("Package diagram", -1);
	q60.AddOption("Deployment diagram", -1);
	q60.AddOption("Class diagram", -1);
	exam.push_back(q60);

	Question q61("Една от разликите между COTS продукт и компонент е, че при първия вид елементи липсва описание на интерфейси?");
	q61.AddOption("Истина", -1);
	q61.AddOption("Лъжа", 1);
	exam.push_back(q61);

	Question q62("Кое от следните твърдения Е вярно по отношение на понятието за компонентнен  модел?");
	q62.AddOption("Нито едно от посочените не е вярно.", -1);
	q62.AddOption("Компонентният модел дефинира стандарт за интерфейсите на командите.", 1);
	q62.AddOption("Компонентният модел не може да се използва при разпределени софтуерни системи.", -1);
	q62.AddOption("Компонентният модел не може да се използва при вградени софтуерни системи.", -1);
	exam.push_back(q62);

	Question q63("Кои от изброените не могат да бъдат класифицирани като нефункционални организационни изисквания?");
	q63.AddOption("Етични изисквания", 0.5);
	q63.AddOption("Изисквания за имплементация", -1);
	q63.AddOption("Изисквания за стандарти", -1);
	q63.AddOption("Изисквания за доставка", -1);
	q63.AddOption("Изисквания за оперативна система", 0.5);
	exam.push_back(q63);

	Question q64("Кое от изброените не е функция на ревюто?");
	q64.AddOption("Оценяване на работата на екипа.", -1);
	q64.AddOption("Управление на проекта.", -1);
	q64.AddOption("Тренировъчна функция.", 1);
	q64.AddOption("Контролиране на качеството на процеса.", -1);
	exam.push_back(q64);

	Question q65("Кое от следните твърдения е вярно за диаграмите на последователност (sequence)?");
	q65.AddOption("Използват се прекъснати стрелки за моделиране на върнат резултат.", 1);
	q65.AddOption("Не показват последователността от взаимодействията между обектите.", -1);
	q65.AddOption("Използват се за моделиране на статична структура на софтуерната система.", -1);
	q65.AddOption("Не се препоръчва използването им при създаване на модели за критични по отношение на безопасността системи", -1);
	exam.push_back(q65);

	Question q66("В 4+1 модела на софтуерната архитектура изгледът на процесите показва как системата се декомпозира на съставни софтуерни елементи (модули)?");
	q66.AddOption("Истина", 1);
	q66.AddOption("Лъжа", -1);
	exam.push_back(q66);

	Question q67("Коя от следните не се класифицира като статична диаграма в UML?");
	q67.AddOption("Activity diagram", 1);
	q67.AddOption("Deployment diagram", -1);
	q67.AddOption("Class diagram", -1);
	q67.AddOption("Package diagram", -1);
	exam.push_back(q67);

	Question q68("Комбинация от тестови случай, тестова процедура и тестови данни (ръчни или автоматизирани) се нарича: ");
	q68.AddOption("Тестов сценарий", 1);
	q68.AddOption("Тестова група", -1);
	q68.AddOption("Тестови случай", -1);
	q68.AddOption("Тестов скрипт", -1);
	exam.push_back(q68);

	Question q69("Кое от изброените е вярно за прилагането на B & B?");
	q69.AddOption("B & B цели намирането на дефекти в системата", 1);
	q69.AddOption("Планирането на B & B трябва да започне след като започне процеса на разработване", -1);
	q69.AddOption("Не е необходимо да се прилага на всяка стъпка", -1);
	q69.AddOption("Трябва да е балансирано относно статична верификация и тестване", -1);
	exam.push_back(q69);

	Question q70("Кои от изброените са 5-те общи рамкови дейности /generic process framework activities / според Пресман ? ");
	q70.AddOption("Комуникация, планиране, моделиране, конструиране, внедряване", 1);
	q70.AddOption("Анализ, планиране, дизайн, програмиране, тестване", -1);
	q70.AddOption("Анализ, дизайн, програмиране, дебъгване, поддръжка", -1);
	q70.AddOption("Комуникация, управление на риска, измерване, създаване, преглед", -1);
	exam.push_back(q70);

	Question q71("UML е език за моделиране на обектно-ориентирани системи.");
	q71.AddOption("Истина", 1);
	q71.AddOption("Лъжа", -1);
	exam.push_back(q71);

	unsigned questionsCount = exam.size();
	for (unsigned i = 0; i < questionsCount; ++i)
		std::swap(exam[Randomize(exam.size())], exam[Randomize(exam.size())]);
	for (unsigned i = 0; i < exam.size(); ++i)
	{
		if (i == questionsCount)
		{
			std::cout << "Sekciq sus sgresheni vuprosi\nnatisnete nqkoy buton\n";
			std::cin >> useless;
			system("CLS");
		}
		std::cout << 1 + i << '/' << exam.size() << '\n';
		exam[i].AskQuestion();
		if (exam[i].AnswerQuestion() != 1 && !flag)
			exam.push_back(exam[i]);
		std::cin >> useless;
		system("CLS");
	}
	std::cout << "Congratulations for reaching the end!\nYour score is: " << counter << '/' << exam.size();
	std::cin >> useless;
	system("pause");
	return 0;
}